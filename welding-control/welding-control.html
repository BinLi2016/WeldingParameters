<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>焊机操作控制</title>
    <style>
        body {
            font-family: 'Consolas', 'Courier New', 'Microsoft YaHei', monospace;
            background: #1e1e1e;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #ffffff;
            overflow: hidden;
        }

        .container {
            background: #2d2d2d;
            border: 3px solid #404040;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            text-align: center;
            min-width: 600px;
            position: relative;
        }

        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
        }

        .title {
            color: #00ff00;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #00ff00;
        }

        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 30px;
        }

        .control-button {
            background: #404040;
            color: #ffffff;
            border: 2px solid #606060;
            padding: 30px 20px;
            font-size: 16px;
            font-weight: bold;
            font-family: 'Consolas', monospace;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-button::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            height: 2px;
            background: #808080;
        }

        .control-button:hover {
            background: #505050;
            border-color: #808080;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.3);
        }

        .control-button:active {
            background: #303030;
            transform: translateY(2px);
        }

        .arc-button {
            background: #4a1a1a;
            border-color: #8b0000;
            grid-column: 1 / -1;
        }

        .arc-button:hover {
            background: #5a2a2a;
            border-color: #a00000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.3);
        }

        .arc-button.active {
            background: #8b0000;
            border-color: #ff0000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.6);
            color: #ffffff;
        }

        .wire-button.active {
            background: #1a4a4a;
            border-color: #008b8b;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            color: #ffffff;
        }

        .motion-button {
            background: #2a2a2a;
            border-color: #606060;
            color: #cccccc;
        }

        .motion-button:hover {
            background: #353535;
            border-color: #808080;
            transform: translateY(-2px);
        }

        .motion-button.active {
            background: #3a3a3a;
            border-color: #909090;
            box-shadow: 0 0 20px rgba(144, 144, 144, 0.6);
            color: #ffffff;
        }

        .status {
            background: #1a1a1a;
            border: 2px solid #404040;
            border-radius: 4px;
            padding: 15px;
            margin-top: 20px;
            color: #00ff00;
            font-size: 14px;
            font-family: 'Consolas', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status.active {
            border-color: #00ff00;
            background: #1a2a1a;
            color: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }

        .status.error {
            border-color: #ff0000;
            background: #2a1a1a;
            color: #ff0000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
        }

        .led-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff0000;
            margin-right: 10px;
            animation: blink 1s infinite;
        }

        .led-indicator.active {
            background: #00ff00;
            animation: none;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .system-info {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 10px;
            color: #808080;
            font-family: 'Consolas', monospace;
        }

        .system-info .status {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 9px;
        }

        .system-info .status.active {
            background: #00ff00;
            color: #000000;
        }

        .system-info .status.error {
            background: #ff0000;
            color: #ffffff;
        }

        .timestamp {
            position: absolute;
            bottom: 10px;
            left: 15px;
            font-size: 10px;
            color: #808080;
            font-family: 'Consolas', monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="system-info">
            SYSTEM: WELDING_CONTROL_v1.0<br>
            STATUS: <span id="connectionStatus">CONNECTING...</span><br>
            ROBOT: <span id="robotStatus">192.168.58.2:20003</span>
        </div>
        
        <h1 class="title">焊机操作控制</h1>
        
        <div class="button-grid">
            <button class="control-button arc-button" id="arcStart">
                <span class="led-indicator" id="arcLed"></span>
                起弧
            </button>
            
            <button class="control-button wire-button" id="wireFeed">
                <span class="led-indicator" id="feedLed"></span>
                进丝
            </button>
            
            <button class="control-button wire-button" id="wireRetract">
                <span class="led-indicator" id="retractLed"></span>
                退丝
            </button>
            
            <button class="control-button motion-button" id="motionXPlus">
                <span class="led-indicator" id="motionXPlusLed"></span>
                点动X+
            </button>
            
            <button class="control-button motion-button" id="motionXMinus">
                <span class="led-indicator" id="motionXMinusLed"></span>
                点动X-
            </button>
        </div>
        
        <div class="status" id="status">
            状态: 待机中
        </div>
        
        <div class="timestamp" id="timestamp"></div>
    </div>

    <script>
        const arcStartBtn = document.getElementById('arcStart');
        const wireFeedBtn = document.getElementById('wireFeed');
        const wireRetractBtn = document.getElementById('wireRetract');
        const motionXPlusBtn = document.getElementById('motionXPlus');
        const motionXMinusBtn = document.getElementById('motionXMinus');
        const statusDiv = document.getElementById('status');
        const arcLed = document.getElementById('arcLed');
        const feedLed = document.getElementById('feedLed');
        const retractLed = document.getElementById('retractLed');
        const motionXPlusLed = document.getElementById('motionXPlusLed');
        const motionXMinusLed = document.getElementById('motionXMinusLed');
        const timestampDiv = document.getElementById('timestamp');
        const connectionStatusDiv = document.getElementById('connectionStatus');
        const robotStatusDiv = document.getElementById('robotStatus');

        let arcActive = false;
        let wireFeedActive = false;
        let wireRetractActive = false;
        let motionXPlusActive = false;
        let motionXMinusActive = false;

        function updateStatus() {
            let statusText = '状态: ';
            let statusClass = '';
            
            if (arcActive) {
                statusText += '起弧中';
                statusClass = 'active';
            } else if (wireFeedActive) {
                statusText += '进丝中';
                statusClass = 'active';
            } else if (wireRetractActive) {
                statusText += '退丝中';
                statusClass = 'active';
            } else if (motionXPlusActive) {
                statusText += '点动X+中';
                statusClass = 'active';
            } else if (motionXMinusActive) {
                statusText += '点动X-中';
                statusClass = 'active';
            } else {
                statusText += '待机中';
            }
            
            statusDiv.textContent = statusText;
            statusDiv.className = 'status ' + statusClass;
        }

        function updateTimestamp() {
            const now = new Date();
            const timeString = now.toLocaleString('zh-CN', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            timestampDiv.textContent = `TIME: ${timeString}`;
        }

        function updateLeds() {
            arcLed.className = arcActive ? 'led-indicator active' : 'led-indicator';
            feedLed.className = wireFeedActive ? 'led-indicator active' : 'led-indicator';
            retractLed.className = wireRetractActive ? 'led-indicator active' : 'led-indicator';
            motionXPlusLed.className = motionXPlusActive ? 'led-indicator active' : 'led-indicator';
            motionXMinusLed.className = motionXMinusActive ? 'led-indicator active' : 'led-indicator';
        }



        // 物理按钮键盘映射配置
        const BUTTON_MAPPINGS = {
            arc: { keys: ['control', 'alt', 'p'], description: '起弧按钮: Ctrl + Alt + P' },
            feed: { keys: ['control', 'alt', 'f'], description: '进丝按钮: Ctrl + Alt + F' },
            retract: { keys: ['control', 'alt', 'r'], description: '退丝按钮: Ctrl + Alt + R' }
        };

        // 键盘按键状态跟踪
        let keysPressed = new Set();

        // 初始化状态
        updateStatus();
        updateLeds();
        updateTimestamp();
        
        // 每秒更新时间戳
        setInterval(updateTimestamp, 1000);

        // XML-RPC 客户端配置
        const ROBOT_IP = "192.168.58.2";
        const ROBOT_PORT = "20003";
        const ROBOT_URL = `http://${ROBOT_IP}:${ROBOT_PORT}`;

        // 焊接参数配置
        const WELDING_CONFIG = {
            // 焊接方法参数
            ioType: 0,              // IO类型: 0-控制器IO, 1-扩展IO
            arcNum: 1,              // 焊机配置文件编号
            arcTimeout: 5000,       // 起弧超时时间 (毫秒)
            
            // 备用：传统数字输出配置 (如果需要手动控制)
            arcDO: 0,           // 起弧数字输出端口
            wireFeedDO: 1,      // 进丝数字输出端口  
            wireRetractDO: 2,   // 退丝数字输出端口
            
            // 备用：模拟输出配置 (如果需要手动控制)
            arcAO: 0,           // 起弧模拟输出端口
            arcPower: 50,       // 起弧功率百分比 (0-100)
            wireFeedAO: 1,      // 进丝模拟输出端口
            wireFeedSpeed: 30,  // 进丝速度百分比 (0-100)
            wireRetractSpeed: 20, // 退丝速度百分比 (0-100)
            
            // 备用：工具数字输出配置
            arcToolDO: 0,       // 起弧工具数字输出端口
        };

        // 简单的XML-RPC客户端实现
        class XMLRPCClient {
            constructor(url) {
                this.url = url;
                this.requestId = 0;
            }

            async call(methodName, ...params) {
                this.requestId++;
                const currentRequestId = this.requestId;
                
                console.log(`[XML-RPC ${currentRequestId}] 调用方法: ${methodName}`, params);
                
                const xmlRequest = this.buildXMLRequest(methodName, params);
                console.log(`[XML-RPC ${currentRequestId}] 请求XML:`, xmlRequest);
                
                try {
                    const response = await fetch(this.url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'text/xml; charset=utf-8',
                            'User-Agent': 'WeldingControl/1.0',
                            'SOAPAction': '""',
                            'Accept': 'text/xml',
                            'Cache-Control': 'no-cache'
                        },
                        body: xmlRequest,
                        mode: 'cors',
                        credentials: 'omit'
                    });

                    console.log(`[XML-RPC ${currentRequestId}] HTTP状态:`, response.status, response.statusText);
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error(`[XML-RPC ${currentRequestId}] HTTP错误响应:`, errorText);
                        throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
                    }

                    const xmlResponse = await response.text();
                    console.log(`[XML-RPC ${currentRequestId}] 响应XML:`, xmlResponse);
                    
                    const result = this.parseXMLResponse(xmlResponse);
                    
                    console.log(`[XML-RPC ${currentRequestId}] 解析结果:`, result);
                    return result;
                } catch (error) {
                    console.error(`[XML-RPC ${currentRequestId}] 调用失败:`, error);
                    return { error: error.message };
                }
            }

            buildXMLRequest(methodName, params) {
                let paramXml = '';
                params.forEach(param => {
                    if (typeof param === 'number') {
                        // Use int for integers, double for floats
                        if (Number.isInteger(param)) {
                            paramXml += `<param><value><int>${param}</int></value></param>`;
                        } else {
                            paramXml += `<param><value><double>${param}</double></value></param>`;
                        }
                    } else if (typeof param === 'string') {
                        paramXml += `<param><value><string>${param}</string></value></param>`;
                    } else if (Array.isArray(param)) {
                        paramXml += `<param><value><array><data>`;
                        param.forEach(item => {
                            if (typeof item === 'number') {
                                if (Number.isInteger(item)) {
                                    paramXml += `<value><int>${item}</int></value>`;
                                } else {
                                    paramXml += `<value><double>${item}</double></value>`;
                                }
                            } else {
                                paramXml += `<value><string>${item}</string></value>`;
                            }
                        });
                        paramXml += `</data></array></value></param>`;
                    }
                });

                return `<?xml version="1.0" encoding="UTF-8"?>
<methodCall>
    <methodName>${methodName}</methodName>
    <params>
        ${paramXml}
    </params>
</methodCall>`;
            }

            parseXMLResponse(xmlString) {
                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlString, "text/xml");
                    
                    // Check for XML parsing errors
                    const parseError = xmlDoc.querySelector('parsererror');
                    if (parseError) {
                        return { error: 'XML parsing error: ' + parseError.textContent };
                    }
                    
                    // Check for fault response
                    const fault = xmlDoc.querySelector('fault');
                    if (fault) {
                        const faultValue = fault.querySelector('value');
                        if (faultValue) {
                            return { error: 'Robot fault: ' + faultValue.textContent };
                        }
                        return { error: 'Robot returned fault' };
                    }

                    // Parse successful response
                    const value = xmlDoc.querySelector('methodResponse params param value');
                    if (value) {
                        const int = value.querySelector('int');
                        const double = value.querySelector('double');
                        const string = value.querySelector('string');
                        const array = value.querySelector('array');
                        
                        if (int) return parseInt(int.textContent);
                        if (double) return parseFloat(double.textContent);
                        if (string) return string.textContent;
                        if (array) {
                            const values = array.querySelectorAll('value');
                            return Array.from(values).map(v => {
                                const i = v.querySelector('int');
                                const d = v.querySelector('double');
                                const s = v.querySelector('string');
                                if (i) return parseInt(i.textContent);
                                if (d) return parseFloat(d.textContent);
                                if (s) return s.textContent;
                                return null;
                            });
                        }
                    }
                    
                    // Default: return 0 for success (common in robot API)
                    return 0;
                } catch (error) {
                    return { error: 'Failed to parse XML response: ' + error.message };
                }
            }
        }

        // Node.js HTTP客户端 (用于Electron环境)
        class NodeXMLRPCClient {
            constructor(ip, port) {
                this.ip = ip;
                this.port = port;
                this.requestId = 0;
                
                // 检查是否在Electron环境中
                if (typeof require !== 'undefined') {
                    try {
                        this.http = require('http');
                        this.isNodeAvailable = true;
                        console.log('Node.js HTTP模块可用，使用Node.js客户端');
                    } catch (e) {
                        this.isNodeAvailable = false;
                        console.log('Node.js HTTP模块不可用，使用浏览器fetch');
                    }
                } else {
                    this.isNodeAvailable = false;
                    console.log('不在Node.js环境中，使用浏览器fetch');
                }
            }
            
            async call(methodName, ...params) {
                this.requestId++;
                const currentRequestId = this.requestId;
                
                console.log(`[Node-XML-RPC ${currentRequestId}] 调用方法: ${methodName}`, params);
                
                const xmlRequest = this.buildXMLRequest(methodName, params);
                console.log(`[Node-XML-RPC ${currentRequestId}] 请求XML:`, xmlRequest);
                
                if (this.isNodeAvailable) {
                    return this.sendNodeRequest(xmlRequest, currentRequestId);
                } else {
                    return this.sendFetchRequest(xmlRequest, currentRequestId);
                }
            }
            
            buildXMLRequest(methodName, params) {
                let paramXml = '';
                params.forEach((param, index) => {
                    if (typeof param === 'number') {
                        // Special handling for StartJOG method - force last 3 parameters to be double
                        if (methodName === 'StartJOG' && index >= 3) {
                            paramXml += `<param><value><double>${param}</double></value></param>`;
                        } else if (param % 1 !== 0 || param.toString().includes('.')) {
                            paramXml += `<param><value><double>${param}</double></value></param>`;
                        } else {
                            paramXml += `<param><value><int>${param}</int></value></param>`;
                        }
                    } else if (typeof param === 'string') {
                        paramXml += `<param><value><string>${param}</string></value></param>`;
                    } else if (Array.isArray(param)) {
                        paramXml += `<param><value><array><data>`;
                        param.forEach(item => {
                            if (typeof item === 'number') {
                                if (item % 1 !== 0 || item.toString().includes('.')) {
                                    paramXml += `<value><double>${item}</double></value>`;
                                } else {
                                    paramXml += `<value><int>${item}</int></value>`;
                                }
                            } else if (typeof item === 'string') {
                                paramXml += `<value><string>${item}</string></value>`;
                            }
                        });
                        paramXml += `</data></array></value></param>`;
                    }
                });

                return `<?xml version="1.0" encoding="UTF-8"?>
<methodCall>
    <methodName>${methodName}</methodName>
    <params>
        ${paramXml}
    </params>
</methodCall>`;
            }
            
            sendNodeRequest(xmlRequest, requestId) {
                return new Promise((resolve, reject) => {
                    const postData = xmlRequest;
                    
                    const options = {
                        hostname: this.ip,
                        port: this.port,
                        path: '/RPC2',
                        method: 'POST',
                        headers: {
                            'Content-Type': 'text/xml; charset=utf-8',
                            'Content-Length': Buffer.byteLength(postData, 'utf8'),
                            'User-Agent': 'WeldingControl-Node/1.0'
                        },
                        timeout: 10000
                    };
                    
                    const req = this.http.request(options, (res) => {
                        console.log(`[Node-XML-RPC ${requestId}] HTTP状态:`, res.statusCode);
                        
                        let responseData = '';
                        res.on('data', (chunk) => {
                            responseData += chunk;
                        });
                        
                        res.on('end', () => {
                            console.log(`[Node-XML-RPC ${requestId}] 响应XML:`, responseData);
                            
                            if (res.statusCode === 200) {
                                const result = this.parseXMLResponse(responseData);
                                console.log(`[Node-XML-RPC ${requestId}] 解析结果:`, result);
                                resolve(result);
                            } else {
                                console.error(`[Node-XML-RPC ${requestId}] HTTP错误:`, res.statusCode, responseData);
                                resolve({ error: `HTTP ${res.statusCode}: ${responseData}` });
                            }
                        });
                    });
                    
                    req.on('error', (e) => {
                        console.error(`[Node-XML-RPC ${requestId}] 请求错误:`, e);
                        resolve({ error: e.message });
                    });
                    
                    req.on('timeout', () => {
                        console.error(`[Node-XML-RPC ${requestId}] 请求超时`);
                        req.destroy();
                        resolve({ error: 'Request timeout' });
                    });
                    
                    req.write(postData);
                    req.end();
                });
            }
            
            async sendFetchRequest(xmlRequest, requestId) {
                try {
                    const response = await fetch(`http://${this.ip}:${this.port}/RPC2`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'text/xml; charset=utf-8',
                            'User-Agent': 'WeldingControl-Fetch/1.0'
                        },
                        body: xmlRequest
                    });

                    console.log(`[Fetch-XML-RPC ${requestId}] HTTP状态:`, response.status);
                    
                    const xmlResponse = await response.text();
                    console.log(`[Fetch-XML-RPC ${requestId}] 响应XML:`, xmlResponse);
                    
                    if (response.ok) {
                        const result = this.parseXMLResponse(xmlResponse);
                        console.log(`[Fetch-XML-RPC ${requestId}] 解析结果:`, result);
                        return result;
                    } else {
                        console.error(`[Fetch-XML-RPC ${requestId}] HTTP错误:`, response.status, xmlResponse);
                        return { error: `HTTP ${response.status}: ${xmlResponse}` };
                    }
                } catch (error) {
                    console.error(`[Fetch-XML-RPC ${requestId}] 调用失败:`, error);
                    return { error: error.message };
                }
            }
            
            parseXMLResponse(xmlString) {
                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlString, "text/xml");
                    
                    const parseError = xmlDoc.querySelector('parsererror');
                    if (parseError) {
                        return { error: 'XML parsing error: ' + parseError.textContent };
                    }
                    
                    const fault = xmlDoc.querySelector('fault');
                    if (fault) {
                        return { error: 'Robot fault: ' + fault.textContent };
                    }

                    const value = xmlDoc.querySelector('methodResponse params param value');
                    if (value) {
                        const int = value.querySelector('int');
                        const double = value.querySelector('double');
                        const string = value.querySelector('string');
                        
                        if (int) return parseInt(int.textContent);
                        if (double) return parseFloat(double.textContent);
                        if (string) return string.textContent;
                    }
                    
                    return 0; // Success
                } catch (error) {
                    return { error: 'Failed to parse XML response: ' + error.message };
                }
            }
        }

        // 创建XML-RPC客户端实例 (使用Node.js增强版本)
        const robotClient = new NodeXMLRPCClient(ROBOT_IP, parseInt(ROBOT_PORT));

        // 焊接动作实现
        class WeldingController {
            constructor(robotClient) {
                this.robotClient = robotClient;
                this.isArcActive = false;
                this.isWireFeedActive = false;
                this.isWireRetractActive = false;
            }

            // 起弧 - 启动焊接电弧
            async startArc() {
                try {
                    console.log('启动焊接电弧...');
                    
                    // 使用专用的起弧方法
                    const result = await this.robotClient.call('ARCStart', 
                        WELDING_CONFIG.ioType,      // IO类型: 0-控制器IO, 1-扩展IO
                        WELDING_CONFIG.arcNum,      // 焊机配置文件编号
                        WELDING_CONFIG.arcTimeout   // 起弧超时时间
                    );
                    
                    if (result.error || result !== 0) {
                        console.error('起弧失败:', result.error || `错误码: ${result}`);
                        return false;
                    }
                    
                    this.isArcActive = true;
                    console.log('焊接电弧已启动 - 使用ARCStart方法');
                    return true;
                } catch (error) {
                    console.error('起弧过程中发生错误:', error);
                    return false;
                }
            }

            // 停止起弧
            async stopArc() {
                try {
                    console.log('停止焊接电弧...');
                    
                    // 使用专用的结束焊接方法
                    const result = await this.robotClient.call('ARCEnd', 
                        WELDING_CONFIG.ioType,      // IO类型: 0-控制器IO, 1-扩展IO
                        WELDING_CONFIG.arcNum,      // 焊机配置文件编号
                        WELDING_CONFIG.arcTimeout   // 熄弧超时时间
                    );
                    
                    // ARCEnd方法通常会返回0表示成功
                    if (result.error && result !== 0) {
                        console.warn('结束焊接方法调用失败，但继续执行:', result.error || `错误码: ${result}`);
                    }
                    
                    this.isArcActive = false;
                    console.log('焊接电弧已停止 - 使用ARCEnd方法');
                    return true;
                } catch (error) {
                    console.error('停止起弧过程中发生错误:', error);
                    this.isArcActive = false; // 确保状态被重置
                    return false;
                }
            }

            // 进丝 - 焊丝送进
            async startWireFeed() {
                try {
                    console.log('启动焊丝送进...');
                    
                    // 使用专用的正向送丝方法
                    const result = await this.robotClient.call('SetForwardWireFeed', 
                        WELDING_CONFIG.ioType,      // IO类型: 0-控制器IO, 1-扩展IO
                        1                           // 送丝控制: 1-送丝
                    );
                    
                    if (result.error || result !== 0) {
                        console.error('进丝失败:', result.error || `错误码: ${result}`);
                        return false;
                    }
                    
                    this.isWireFeedActive = true;
                    console.log('焊丝送进已启动 - 使用SetForwardWireFeed方法');
                    return true;
                } catch (error) {
                    console.error('进丝过程中发生错误:', error);
                    return false;
                }
            }

            // 停止进丝
            async stopWireFeed() {
                try {
                    console.log('停止焊丝送进...');
                    
                    // 使用专用的正向送丝方法停止送丝
                    const result = await this.robotClient.call('SetForwardWireFeed', 
                        WELDING_CONFIG.ioType,      // IO类型: 0-控制器IO, 1-扩展IO
                        0                           // 送丝控制: 0-停止送丝
                    );
                    
                    if (result.error && result !== 0) {
                        console.warn('停止进丝方法调用失败，但继续执行:', result.error || `错误码: ${result}`);
                    }
                    
                    this.isWireFeedActive = false;
                    console.log('焊丝送进已停止 - 使用SetForwardWireFeed方法');
                    return true;
                } catch (error) {
                    console.error('停止进丝过程中发生错误:', error);
                    this.isWireFeedActive = false; // 确保状态被重置
                    return false;
                }
            }

            // 退丝 - 焊丝回退
            async startWireRetract() {
                try {
                    console.log('启动焊丝回退...');
                    
                    // 使用专用的反向送丝方法
                    const result = await this.robotClient.call('SetReverseWireFeed', 
                        WELDING_CONFIG.ioType,      // IO类型: 0-控制器IO, 1-扩展IO
                        1                           // 送丝控制: 1-送丝 (反向)
                    );
                    
                    if (result.error || result !== 0) {
                        console.error('退丝失败:', result.error || `错误码: ${result}`);
                        return false;
                    }
                    
                    this.isWireRetractActive = true;
                    console.log('焊丝回退已启动 - 使用SetReverseWireFeed方法');
                    return true;
                } catch (error) {
                    console.error('退丝过程中发生错误:', error);
                    return false;
                }
            }

            // 停止退丝
            async stopWireRetract() {
                try {
                    console.log('停止焊丝回退...');
                    
                    // 使用专用的反向送丝方法停止送丝
                    const result = await this.robotClient.call('SetReverseWireFeed', 
                        WELDING_CONFIG.ioType,      // IO类型: 0-控制器IO, 1-扩展IO
                        0                           // 送丝控制: 0-停止送丝
                    );
                    
                    if (result.error && result !== 0) {
                        console.warn('停止退丝方法调用失败，但继续执行:', result.error || `错误码: ${result}`);
                    }
                    
                    this.isWireRetractActive = false;
                    console.log('焊丝回退已停止 - 使用SetReverseWireFeed方法');
                    return true;
                } catch (error) {
                    console.error('停止退丝过程中发生错误:', error);
                    this.isWireRetractActive = false; // 确保状态被重置
                    return false;
                }
            }

            // 点动X+ - 开始X轴正向运动
            async startMotionXPlus() {
                try {
                    console.log('启动运动测试 - X轴正向100mm...');
                    
                    // 使用StartJOG方法进行X轴正向运动
                    // ref=2(基坐标系), nb=1(X轴), dir=1(正方向), max_dis=100mm, vel=10%
                    const result = await this.robotClient.call('StartJOG', 
                        2,              // ref: 基坐标系点动
                        1,              // nb: X轴
                        1,              // dir: 正方向
                        parseFloat(100.0),  // max_dis: 100mm (强制作为double)
                        parseFloat(10.0),   // vel: 10% 速度 (强制作为double)
                        parseFloat(100.0)   // acc: 100% 加速度 (强制作为double)
                    );
                    
                    if (result.error || result !== 0) {
                        console.error('运动测试启动失败:', result.error || `错误码: ${result}`);
                        return false;
                    }
                    
                    this.isMotionXPlusActive = true;
                    console.log('点动X+已启动 - X轴正向运动');
                    return true;
                } catch (error) {
                    console.error('点动X+过程中发生错误:', error);
                    return false;
                }
            }

            // 点动X+ - 停止运动
            async stopMotionXPlus() {
                try {
                    console.log('停止运动测试...');
                    
                    // 使用StopJOG方法停止基坐标系点动
                    // ref=3 表示基坐标系点动停止
                    const result = await this.robotClient.call('StopJOG', 3);
                    
                    if (result.error && result !== 0) {
                        console.warn('停止运动测试方法调用失败，但继续执行:', result.error || `错误码: ${result}`);
                    }
                    
                    this.isMotionXPlusActive = false;
                    console.log('点动X+已停止');
                    return true;
                } catch (error) {
                    console.error('停止点动X+过程中发生错误:', error);
                    this.isMotionXPlusActive = false; // 确保状态被重置
                    return false;
                }
            }

            // 点动X- - 开始X轴负向运动
            async startMotionXMinus() {
                try {
                    console.log('启动点动X- - X轴负向100mm...');
                    
                    // 使用StartJOG方法进行X轴负向运动
                    // ref=2(基坐标系), nb=1(X轴), dir=0(负方向), max_dis=100mm, vel=10%
                    const result = await this.robotClient.call('StartJOG', 
                        2,              // ref: 基坐标系点动
                        1,              // nb: X轴
                        0,              // dir: 负方向
                        parseFloat(100.0),  // max_dis: 100mm (强制作为double)
                        parseFloat(10.0),   // vel: 10% 速度 (强制作为double)
                        parseFloat(100.0)   // acc: 100% 加速度 (强制作为double)
                    );
                    
                    if (result.error || result !== 0) {
                        console.error('点动X-启动失败:', result.error || `错误码: ${result}`);
                        return false;
                    }
                    
                    this.isMotionXMinusActive = true;
                    console.log('点动X-已启动 - X轴负向运动');
                    return true;
                } catch (error) {
                    console.error('点动X-过程中发生错误:', error);
                    return false;
                }
            }

            // 点动X- - 停止运动
            async stopMotionXMinus() {
                try {
                    console.log('停止点动X-...');
                    
                    // 使用StopJOG方法停止基坐标系点动
                    // ref=3 表示基坐标系点动停止
                    const result = await this.robotClient.call('StopJOG', 3);
                    
                    if (result.error && result !== 0) {
                        console.warn('停止点动X-方法调用失败，但继续执行:', result.error || `错误码: ${result}`);
                    }
                    
                    this.isMotionXMinusActive = false;
                    console.log('点动X-已停止');
                    return true;
                } catch (error) {
                    console.error('停止点动X-过程中发生错误:', error);
                    this.isMotionXMinusActive = false; // 确保状态被重置
                    return false;
                }
            }

            // 获取机器人状态
            async getRobotStatus() {
                try {
                    const result = await this.robotClient.call('GetRobotErrorCode');
                    if (result.error) {
                        return { error: result.error };
                    }
                    return { errorCode: result };
                } catch (error) {
                    return { error: error.message };
                }
            }
        }

        // 创建焊接控制器实例
        const weldingController = new WeldingController(robotClient);

        // 修改现有的事件处理器，集成焊接控制
        arcStartBtn.addEventListener('mousedown', async () => {
            // 按下鼠标开始起弧
            const success = await weldingController.startArc();
            if (success) {
                arcActive = true;
                updateStatus();
                arcStartBtn.classList.add('active');
                arcStartBtn.innerHTML = '<span class="led-indicator active" id="arcLed"></span>起弧中...';
                updateLeds();
            } else {
                console.error('起弧失败');
                // 可以在这里添加错误提示UI
            }
        });

        arcStartBtn.addEventListener('mouseup', async () => {
            // 释放鼠标停止起弧
            await weldingController.stopArc();
            arcActive = false;
            updateStatus();
            arcStartBtn.classList.remove('active');
            arcStartBtn.innerHTML = '<span class="led-indicator" id="arcLed"></span>起弧';
            updateLeds();
        });

        arcStartBtn.addEventListener('mouseleave', async () => {
            // 鼠标离开按钮时停止起弧
            if (arcActive) {
                await weldingController.stopArc();
                arcActive = false;
                updateStatus();
                arcStartBtn.classList.remove('active');
                arcStartBtn.innerHTML = '<span class="led-indicator" id="arcLed"></span>起弧';
                updateLeds();
            }
        });

        wireFeedBtn.addEventListener('mousedown', async () => {
            // 按下鼠标开始进丝
            const success = await weldingController.startWireFeed();
            if (success) {
                wireFeedActive = true;
                updateStatus();
                wireFeedBtn.classList.add('active');
                wireFeedBtn.innerHTML = '<span class="led-indicator active" id="feedLed"></span>进丝中...';
                updateLeds();
            } else {
                console.error('进丝失败');
            }
        });

        wireFeedBtn.addEventListener('mouseup', async () => {
            // 释放鼠标停止进丝
            await weldingController.stopWireFeed();
            wireFeedActive = false;
            updateStatus();
            wireFeedBtn.classList.remove('active');
            wireFeedBtn.innerHTML = '<span class="led-indicator" id="feedLed"></span>进丝';
            updateLeds();
        });

        wireFeedBtn.addEventListener('mouseleave', async () => {
            // 鼠标离开按钮时停止进丝
            if (wireFeedActive) {
                await weldingController.stopWireFeed();
                wireFeedActive = false;
                updateStatus();
                wireFeedBtn.classList.remove('active');
                wireFeedBtn.innerHTML = '<span class="led-indicator" id="feedLed"></span>进丝';
                updateLeds();
            }
        });

        wireRetractBtn.addEventListener('mousedown', async () => {
            // 按下鼠标开始退丝
            const success = await weldingController.startWireRetract();
            if (success) {
                wireRetractActive = true;
                updateStatus();
                wireRetractBtn.classList.add('active');
                wireRetractBtn.innerHTML = '<span class="led-indicator active" id="retractLed"></span>退丝中...';
                updateLeds();
            } else {
                console.error('退丝失败');
            }
        });

        wireRetractBtn.addEventListener('mouseup', async () => {
            // 释放鼠标停止退丝
            await weldingController.stopWireRetract();
            wireRetractActive = false;
            updateStatus();
            wireRetractBtn.classList.remove('active');
            wireRetractBtn.innerHTML = '<span class="led-indicator" id="retractLed"></span>退丝';
            updateLeds();
        });

        wireRetractBtn.addEventListener('mouseleave', async () => {
            // 鼠标离开按钮时停止退丝
            if (wireRetractActive) {
                await weldingController.stopWireRetract();
                wireRetractActive = false;
                updateStatus();
                wireRetractBtn.classList.remove('active');
                wireRetractBtn.innerHTML = '<span class="led-indicator" id="retractLed"></span>退丝';
                updateLeds();
            }
        });

        // 点动X+按钮事件处理
        motionXPlusBtn.addEventListener('mousedown', async () => {
            // 按下鼠标开始X+运动
            const success = await weldingController.startMotionXPlus();
            if (success) {
                motionXPlusActive = true;
                updateStatus();
                motionXPlusBtn.classList.add('active');
                motionXPlusBtn.innerHTML = '<span class="led-indicator active" id="motionXPlusLed"></span>运动中...';
                updateLeds();
            } else {
                console.error('点动X+失败');
            }
        });

        motionXPlusBtn.addEventListener('mouseup', async () => {
            // 释放鼠标停止X+运动
            await weldingController.stopMotionXPlus();
            motionXPlusActive = false;
            updateStatus();
            motionXPlusBtn.classList.remove('active');
            motionXPlusBtn.innerHTML = '<span class="led-indicator" id="motionXPlusLed"></span>点动X+';
            updateLeds();
        });

        motionXPlusBtn.addEventListener('mouseleave', async () => {
            // 鼠标离开按钮时停止X+运动
            if (motionXPlusActive) {
                await weldingController.stopMotionXPlus();
                motionXPlusActive = false;
                updateStatus();
                motionXPlusBtn.classList.remove('active');
                motionXPlusBtn.innerHTML = '<span class="led-indicator" id="motionXPlusLed"></span>点动X+';
                updateLeds();
            }
        });

        // 点动X-按钮事件处理
        motionXMinusBtn.addEventListener('mousedown', async () => {
            // 按下鼠标开始X-运动
            const success = await weldingController.startMotionXMinus();
            if (success) {
                motionXMinusActive = true;
                updateStatus();
                motionXMinusBtn.classList.add('active');
                motionXMinusBtn.innerHTML = '<span class="led-indicator active" id="motionXMinusLed"></span>运动中...';
                updateLeds();
            } else {
                console.error('点动X-失败');
            }
        });

        motionXMinusBtn.addEventListener('mouseup', async () => {
            // 释放鼠标停止X-运动
            await weldingController.stopMotionXMinus();
            motionXMinusActive = false;
            updateStatus();
            motionXMinusBtn.classList.remove('active');
            motionXMinusBtn.innerHTML = '<span class="led-indicator" id="motionXMinusLed"></span>点动X-';
            updateLeds();
        });

        motionXMinusBtn.addEventListener('mouseleave', async () => {
            // 鼠标离开按钮时停止X-运动
            if (motionXMinusActive) {
                await weldingController.stopMotionXMinus();
                motionXMinusActive = false;
                updateStatus();
                motionXMinusBtn.classList.remove('active');
                motionXMinusBtn.innerHTML = '<span class="led-indicator" id="motionXMinusLed"></span>点动X-';
                updateLeds();
            }
        });

        // 修改键盘事件处理器，集成焊接控制
        document.addEventListener('keydown', async (event) => {
            keysPressed.add(event.key.toLowerCase());
            
            // 检查是否按下起弧组合键 (Ctrl + Alt + P)
            if (keysPressed.has('control') && keysPressed.has('alt') && keysPressed.has('p')) {
                if (!arcActive) {
                    const success = await weldingController.startArc();
                    if (success) {
                        arcActive = true;
                        updateStatus();
                        arcStartBtn.classList.add('active');
                        arcStartBtn.innerHTML = '<span class="led-indicator active" id="arcLed"></span>起弧中...';
                        updateLeds();
                    }
                }
            }
            
            // 检查是否按下进丝组合键 (Ctrl + Alt + F)
            if (keysPressed.has('control') && keysPressed.has('alt') && keysPressed.has('f')) {
                if (!wireFeedActive) {
                    const success = await weldingController.startWireFeed();
                    if (success) {
                        wireFeedActive = true;
                        updateStatus();
                        wireFeedBtn.classList.add('active');
                        wireFeedBtn.innerHTML = '<span class="led-indicator active" id="feedLed"></span>进丝中...';
                        updateLeds();
                    }
                }
            }
            
            // 检查是否按下退丝组合键 (Ctrl + Alt + R)
            if (keysPressed.has('control') && keysPressed.has('alt') && keysPressed.has('r')) {
                if (!wireRetractActive) {
                    const success = await weldingController.startWireRetract();
                    if (success) {
                        wireRetractActive = true;
                        updateStatus();
                        wireRetractBtn.classList.add('active');
                        wireRetractBtn.innerHTML = '<span class="led-indicator active" id="retractLed"></span>退丝中...';
                        updateLeds();
                    }
                }
            }
        });

        document.addEventListener('keyup', async (event) => {
            keysPressed.delete(event.key.toLowerCase());
            
            // 检查是否释放起弧组合键
            if (!keysPressed.has('control') || !keysPressed.has('alt') || !keysPressed.has('p')) {
                if (arcActive) {
                    await weldingController.stopArc();
                    arcActive = false;
                    updateStatus();
                    arcStartBtn.classList.remove('active');
                    arcStartBtn.innerHTML = '<span class="led-indicator" id="arcLed"></span>起弧';
                    updateLeds();
                }
            }
            
            // 检查是否释放进丝组合键
            if (!keysPressed.has('control') || !keysPressed.has('alt') || !keysPressed.has('f')) {
                if (wireFeedActive) {
                    await weldingController.stopWireFeed();
                    wireFeedActive = false;
                    updateStatus();
                    wireFeedBtn.classList.remove('active');
                    wireFeedBtn.innerHTML = '<span class="led-indicator" id="feedLed"></span>进丝';
                    updateLeds();
                }
            }
            
            // 检查是否释放退丝组合键
            if (!keysPressed.has('control') || !keysPressed.has('alt') || !keysPressed.has('r')) {
                if (wireRetractActive) {
                    await weldingController.stopWireRetract();
                    wireRetractActive = false;
                    updateStatus();
                    wireRetractBtn.classList.remove('active');
                    wireRetractBtn.innerHTML = '<span class="led-indicator" id="retractLed"></span>退丝';
                    updateLeds();
                }
            }
        });

        // 添加连接状态检查
        async function checkRobotConnection() {
            try {
                const status = await weldingController.getRobotStatus();
                if (status.error) {
                    console.warn('机器人连接状态:', status.error);
                    connectionStatusDiv.textContent = '连接失败';
                    connectionStatusDiv.className = 'status error';
                    robotStatusDiv.textContent = 'N/A';
                } else {
                    console.log('机器人连接正常, 错误码:', status.errorCode);
                    connectionStatusDiv.textContent = '已连接';
                    connectionStatusDiv.className = 'status active';
                    robotStatusDiv.textContent = `${ROBOT_IP}:${ROBOT_PORT}`;
                }
            } catch (error) {
                console.error('检查机器人连接失败:', error);
                connectionStatusDiv.textContent = '连接失败';
                connectionStatusDiv.className = 'status error';
                robotStatusDiv.textContent = 'N/A';
            }
        }

        // 测试基本网络连接
        async function testBasicConnectivity() {
            console.log('测试基本网络连接...');
            try {
                // 尝试简单的HTTP请求到机器人IP
                const response = await fetch(`http://${ROBOT_IP}:${ROBOT_PORT}`, {
                    method: 'GET',
                    mode: 'no-cors',
                    timeout: 5000
                });
                console.log('基本连接测试 - 收到响应');
                return true;
            } catch (error) {
                console.error('基本连接测试失败:', error);
                return false;
            }
        }

        // 测试XML-RPC连接
        async function testXMLRPCConnection() {
            console.log('测试XML-RPC连接...');
            
            // 首先测试基本连接
            const basicConnectivity = await testBasicConnectivity();
            if (!basicConnectivity) {
                console.error('基本网络连接失败，跳过XML-RPC测试');
                return false;
            }
            
            try {
                // 尝试调用一个简单的机器人方法
                console.log('尝试调用GetSDKVersion方法...');
                const result = await robotClient.call('GetSDKVersion');
                console.log('GetSDKVersion调用结果:', result);
                
                if (result && result.error) {
                    console.error('XML-RPC连接测试失败:', result.error);
                    return false;
                } else {
                    console.log('XML-RPC连接测试成功:', result);
                    return true;
                }
            } catch (error) {
                console.error('XML-RPC连接测试异常:', error);
                return false;
            }
        }

        // 页面加载完成后检查连接
        window.addEventListener('load', async () => {
            setTimeout(async () => {
                console.log('开始检查机器人连接...');
                
                // 首先测试XML-RPC连接
                const xmlrpcTest = await testXMLRPCConnection();
                if (xmlrpcTest) {
                    console.log('XML-RPC连接正常，继续检查机器人状态...');
                    await checkRobotConnection();
                } else {
                    console.error('XML-RPC连接失败，无法与机器人通信');
                    connectionStatusDiv.textContent = 'XML-RPC失败';
                    connectionStatusDiv.className = 'status error';
                    robotStatusDiv.textContent = 'N/A';
                }
            }, 2000); // 延迟2秒检查，等待页面完全加载
        });

        // 定期检查连接状态（每30秒）
        setInterval(checkRobotConnection, 30000);
    </script>
</body>
</html>
